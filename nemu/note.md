1. strtok会改变传入的字符串，所以传入的字符串不能以char *a="xxx"方式定义，因为这是只读字符串。修改只读区域会segfault。
2. expr中规则前面两个转义\,第一个是c语言的，表示后面的\是\字符，后面的\是正则中的转义
3. make -p可以查看所有make内部变量，对于学习make有好处
4. 调试指令集实现时，遇到一个程序出错，则先简化，简化到出错与不出错边界

| | 被调用者不用，调用者用 | 被调用者用，调用者用 | 被调用者不用，调用者也不用 | 被调用者用，调用者不用 |
| - | - | - | - | - |
| 调用者保存寄存器(前后不保证一致) | 保存 | 保存 | 不保存 | 不保存 |
| 被调用者保存寄存器(前后保证一致) | 不保存 | 保存 | 不保存 | 保存 |

编译函数都是调用者视角，所以调用者还要用的寄存器建议使用被调用者保存寄存器，不用的建议使用调用者保存寄存器

riscv指令学习

- _start:
    - li s0, 0 加载0到s0，li是加载值到寄存器，可以用addi和lui实现
    - jal应该可以换成j，也不返回，可以试试
    - _start是汇编定义的符号而不是函数，所以大小是0，可以换成函数，然后ftrace可以捕捉
- _trm_init
    - 返回寄存器是调用者保存(前后不保证一致)，是否被调用者保存好点？？
    - 开始时就计算好所需要的栈大小，进行减栈
- halt
    - 编译时自动内联了，在halt前面加`__attribute_noinline__`后发现有这个函数了

- jal是保存下一指令地址，jal可能是函数最后一个指令吗？
